
// Code generated by MetaFFI. DO NOT EDIT.
// Host code for py_extractor.json
package py_extractor

import "fmt"
import "unsafe"
import . "github.com/MetaFFI/lang-plugin-go/go-runtime"

/*
#cgo !windows LDFLAGS: -L. -ldl
#cgo CFLAGS: -I"C:/src/github.com/MetaFFI/metaffi-core/out/windows/x64/debug"

#include <stdlib.h>
#include <stdint.h>
#include <include/cdt_structs.h>
#include <include/cdt_capi_loader.h>

metaffi_handle get_null_handle();
metaffi_size get_int_item(metaffi_size* array, int index);
void* convert_union_to_ptr(void* p);
void set_cdt_type(struct cdt* p, metaffi_type t);
metaffi_type get_cdt_type(struct cdt* p);
metaffi_size len_to_metaffi_size(long long i);
*/
import "C"



// function IDs








var variable_info_get_name_id unsafe.Pointer


var variable_info_get_type_id unsafe.Pointer


var variable_info_get_is_getter_id unsafe.Pointer


var variable_info_get_is_setter_id unsafe.Pointer





var variable_info_Releasevariable_info_id unsafe.Pointer



var parameter_info_get_name_id unsafe.Pointer


var parameter_info_get_type_id unsafe.Pointer


var parameter_info_get_is_default_value_id unsafe.Pointer


var parameter_info_get_is_optional_id unsafe.Pointer


var parameter_info_get_kind_id unsafe.Pointer





var parameter_info_Releaseparameter_info_id unsafe.Pointer



var function_info_get_name_id unsafe.Pointer


var function_info_get_comment_id unsafe.Pointer


var function_info_get_parameters_id unsafe.Pointer


var function_info_get_return_values_id unsafe.Pointer





var function_info_Releasefunction_info_id unsafe.Pointer



var class_info_get_name_id unsafe.Pointer


var class_info_get_comment_id unsafe.Pointer


var class_info_get_fields_id unsafe.Pointer


var class_info_get_methods_id unsafe.Pointer





var class_info_Releaseclass_info_id unsafe.Pointer



var py_info_get_globals_id unsafe.Pointer


var py_info_get_functions_id unsafe.Pointer


var py_info_get_classes_id unsafe.Pointer





var py_info_Releasepy_info_id unsafe.Pointer




var py_extractor_extract_id unsafe.Pointer


var py_extractor_py_extractor_id unsafe.Pointer


var py_extractor_Releasepy_extractor_id unsafe.Pointer




func Load(modulePath string){
	loadCDTCAPI()

	runtime_plugin := "xllr.python3"
	pruntime_plugin := C.CString(runtime_plugin)
	runtime_plugin_length := C.uint32_t(len(runtime_plugin))

	// load foreign runtime
	var out_err *C.char
    var out_err_len C.uint32_t
    out_err_len = C.uint32_t(0)
	C.xllr_load_runtime_plugin(pruntime_plugin, runtime_plugin_length, &out_err, &out_err_len)
	if out_err_len != C.uint32_t(0){
		panic(fmt.Errorf("Failed to load runtime %v: %v", runtime_plugin, string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len)))))
	}

	// load functions
	loadFF := func(modulePath string, fpath string, params_count int, retval_count int) unsafe.Pointer{
		ppath := C.CString(fpath)
		defer C.free(unsafe.Pointer(ppath))

		pmodulePath := C.CString(modulePath)
		defer C.free(unsafe.Pointer(pmodulePath))

		var out_err *C.char
		var out_err_len C.uint32_t
		out_err_len = C.uint32_t(0)
		id := C.xllr_load_function(pruntime_plugin, runtime_plugin_length, pmodulePath, C.uint(len(modulePath)), ppath, C.uint(len(fpath)), nil,  C.schar(params_count), C.schar(params_count), &out_err, &out_err_len)

		if id == nil{ // failed
			panic(fmt.Errorf("Failed to load foreign entity entrypoint \"%v\": %v", fpath, string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len)))))
		}

		return id
	}

	
	

	

	
	
	variable_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_type_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_type,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_is_getter_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_is_getter,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_is_setter_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_is_setter,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	variable_info_Releasevariable_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_Releasevariable_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	parameter_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_type_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_type,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_is_default_value_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_is_default_value,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_is_optional_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_is_optional,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_kind_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_kind,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	parameter_info_Releaseparameter_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_Releaseparameter_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	function_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_comment_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_comment,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_parameters_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_parameters,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_return_values_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_return_values,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	function_info_Releasefunction_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_Releasefunction_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	class_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_comment_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_comment,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_fields_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_fields,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_methods_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_methods,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	class_info_Releaseclass_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_Releaseclass_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	py_info_get_globals_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_globals,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_info_get_functions_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_functions,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_info_get_classes_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_classes,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	py_info_Releasepy_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_Releasepy_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	
	py_extractor_extract_id = loadFF(modulePath, `entrypoint_class=py_extractor,entrypoint_function=EntryPoint_py_extractor_extract,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_extractor_py_extractor_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_extractor_py_extractor,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_extractor_Releasepy_extractor_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_extractor_Releasepy_extractor,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
}

func Free(){
	runtime_plugin := "xllr.python3"
    pruntime_plugin := C.CString(runtime_plugin)
    runtime_plugin_length := C.uint32_t(len(runtime_plugin))

    var out_err *C.char
    var out_err_len C.uint32_t
    out_err_len = C.uint32_t(0)
    C.xllr_free_runtime_plugin(pruntime_plugin, runtime_plugin_length, &out_err, &out_err_len)
}









// Code to call foreign functions in module py_extractor via XLLR



type Variable_info struct{
	h Handle
}



func (this *Variable_info) GetHandle() Handle{
	return this.h
}

func (this *Variable_info) SetHandle(h Handle){
	this.h = h
}



func (this *Variable_info) GetName() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(variable_info_get_name_id, xcall_params, &out_err, &out_err_len)  // call function pointer variable_info_get_name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed variable_info.get_name. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Variable_info) GetType() (type__ string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(variable_info_get_type_id, xcall_params, &out_err, &out_err_len)  // call function pointer variable_info_get_type_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed variable_info.get_type. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	type__AsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *Variable_info) GetIsGetter() (is_getter bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(variable_info_get_is_getter_id, xcall_params, &out_err, &out_err_len)  // call function pointer variable_info_get_is_getter_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed variable_info.get_is_getter. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	is_getterAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if is_getterAsInterface != nil{
		
		// not handle
		is_getter = bool(is_getterAsInterface.(bool))
		
		
	}

	

	return is_getter, nil	
}




func (this *Variable_info) GetIsSetter() (is_setter bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(variable_info_get_is_setter_id, xcall_params, &out_err, &out_err_len)  // call function pointer variable_info_get_is_setter_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed variable_info.get_is_setter. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	is_setterAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if is_setterAsInterface != nil{
		
		// not handle
		is_setter = bool(is_setterAsInterface.(bool))
		
		
	}

	

	return is_setter, nil	
}





func (this *Variable_info) ReleasevariableInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(variable_info_Releasevariable_info_id, xcall_params, &out_err, &out_err_len)  // call function pointer variable_info_Releasevariable_info_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed variable_info.Releasevariable_info. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type Parameter_info struct{
	h Handle
}



func (this *Parameter_info) GetHandle() Handle{
	return this.h
}

func (this *Parameter_info) SetHandle(h Handle){
	this.h = h
}



func (this *Parameter_info) GetName() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(parameter_info_get_name_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_get_name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.get_name. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Parameter_info) GetType() (type__ string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(parameter_info_get_type_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_get_type_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.get_type. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	type__AsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *Parameter_info) GetIsDefaultValue() (is_default_value bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(parameter_info_get_is_default_value_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_get_is_default_value_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.get_is_default_value. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	is_default_valueAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if is_default_valueAsInterface != nil{
		
		// not handle
		is_default_value = bool(is_default_valueAsInterface.(bool))
		
		
	}

	

	return is_default_value, nil	
}




func (this *Parameter_info) GetIsOptional() (is_optional bool, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(parameter_info_get_is_optional_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_get_is_optional_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.get_is_optional. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	is_optionalAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if is_optionalAsInterface != nil{
		
		// not handle
		is_optional = bool(is_optionalAsInterface.(bool))
		
		
	}

	

	return is_optional, nil	
}




func (this *Parameter_info) GetKind() (kind string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(parameter_info_get_kind_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_get_kind_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.get_kind. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	kindAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if kindAsInterface != nil{
		
		// not handle
		kind = string(kindAsInterface.(string))
		
		
	}

	

	return kind, nil	
}





func (this *Parameter_info) ReleaseparameterInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(parameter_info_Releaseparameter_info_id, xcall_params, &out_err, &out_err_len)  // call function pointer parameter_info_Releaseparameter_info_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed parameter_info.Releaseparameter_info. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type Function_info struct{
	h Handle
}



func (this *Function_info) GetHandle() Handle{
	return this.h
}

func (this *Function_info) SetHandle(h Handle){
	this.h = h
}



func (this *Function_info) GetName() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(function_info_get_name_id, xcall_params, &out_err, &out_err_len)  // call function pointer function_info_get_name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed function_info.get_name. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Function_info) GetComment() (comment string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(function_info_get_comment_id, xcall_params, &out_err, &out_err_len)  // call function pointer function_info_get_comment_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed function_info.get_comment. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	commentAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if commentAsInterface != nil{
		
		// not handle
		comment = string(commentAsInterface.(string))
		
		
	}

	

	return comment, nil	
}




func (this *Function_info) GetParameters() (parameters []Parameter_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(function_info_get_parameters_id, xcall_params, &out_err, &out_err_len)  // call function pointer function_info_get_parameters_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed function_info.get_parameters. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	parametersAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if parametersAsInterface != nil{
		 
		// handle
		
		 
		if len(parametersAsInterface.([]interface{})) > 0{
			parameters = make([]Parameter_info, len(parametersAsInterface.([]interface{})))
			if _, ok := parametersAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range parametersAsInterface.([]interface{}){
					parameters[i] = Parameter_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range parametersAsInterface.([]interface{}){
					parameters[i] = obj.(Parameter_info)
				}
			}
		}
		
		

		
	}

	

	return parameters, nil	
}




func (this *Function_info) GetReturnValues() (return_values []string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(function_info_get_return_values_id, xcall_params, &out_err, &out_err_len)  // call function pointer function_info_get_return_values_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed function_info.get_return_values. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	return_valuesAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if return_valuesAsInterface != nil{
		
		// not handle
		return_values = []string(return_valuesAsInterface.([]string))
		
		
	}

	

	return return_values, nil	
}





func (this *Function_info) ReleasefunctionInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(function_info_Releasefunction_info_id, xcall_params, &out_err, &out_err_len)  // call function pointer function_info_Releasefunction_info_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed function_info.Releasefunction_info. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type Class_info struct{
	h Handle
}



func (this *Class_info) GetHandle() Handle{
	return this.h
}

func (this *Class_info) SetHandle(h Handle){
	this.h = h
}



func (this *Class_info) GetName() (name string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(class_info_get_name_id, xcall_params, &out_err, &out_err_len)  // call function pointer class_info_get_name_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed class_info.get_name. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	nameAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Class_info) GetComment() (comment string, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(class_info_get_comment_id, xcall_params, &out_err, &out_err_len)  // call function pointer class_info_get_comment_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed class_info.get_comment. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	commentAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if commentAsInterface != nil{
		
		// not handle
		comment = string(commentAsInterface.(string))
		
		
	}

	

	return comment, nil	
}




func (this *Class_info) GetFields() (fields []Variable_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(class_info_get_fields_id, xcall_params, &out_err, &out_err_len)  // call function pointer class_info_get_fields_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed class_info.get_fields. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	fieldsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if fieldsAsInterface != nil{
		 
		// handle
		
		 
		if len(fieldsAsInterface.([]interface{})) > 0{
			fields = make([]Variable_info, len(fieldsAsInterface.([]interface{})))
			if _, ok := fieldsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range fieldsAsInterface.([]interface{}){
					fields[i] = Variable_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range fieldsAsInterface.([]interface{}){
					fields[i] = obj.(Variable_info)
				}
			}
		}
		
		

		
	}

	

	return fields, nil	
}




func (this *Class_info) GetMethods() (methods []Function_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(class_info_get_methods_id, xcall_params, &out_err, &out_err_len)  // call function pointer class_info_get_methods_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed class_info.get_methods. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	methodsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if methodsAsInterface != nil{
		 
		// handle
		
		 
		if len(methodsAsInterface.([]interface{})) > 0{
			methods = make([]Function_info, len(methodsAsInterface.([]interface{})))
			if _, ok := methodsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range methodsAsInterface.([]interface{}){
					methods[i] = Function_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range methodsAsInterface.([]interface{}){
					methods[i] = obj.(Function_info)
				}
			}
		}
		
		

		
	}

	

	return methods, nil	
}





func (this *Class_info) ReleaseclassInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(class_info_Releaseclass_info_id, xcall_params, &out_err, &out_err_len)  // call function pointer class_info_Releaseclass_info_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed class_info.Releaseclass_info. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type Py_info struct{
	h Handle
}



func (this *Py_info) GetHandle() Handle{
	return this.h
}

func (this *Py_info) SetHandle(h Handle){
	this.h = h
}



func (this *Py_info) GetGlobals() (globals []Variable_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(py_info_get_globals_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_info_get_globals_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_info.get_globals. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	globalsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if globalsAsInterface != nil{
		 
		// handle
		
		 
		if len(globalsAsInterface.([]interface{})) > 0{
			globals = make([]Variable_info, len(globalsAsInterface.([]interface{})))
			if _, ok := globalsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range globalsAsInterface.([]interface{}){
					globals[i] = Variable_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range globalsAsInterface.([]interface{}){
					globals[i] = obj.(Variable_info)
				}
			}
		}
		
		

		
	}

	

	return globals, nil	
}




func (this *Py_info) GetFunctions() (functions []Function_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(py_info_get_functions_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_info_get_functions_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_info.get_functions. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	functionsAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if functionsAsInterface != nil{
		 
		// handle
		
		 
		if len(functionsAsInterface.([]interface{})) > 0{
			functions = make([]Function_info, len(functionsAsInterface.([]interface{})))
			if _, ok := functionsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range functionsAsInterface.([]interface{}){
					functions[i] = Function_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range functionsAsInterface.([]interface{}){
					functions[i] = obj.(Function_info)
				}
			}
		}
		
		

		
	}

	

	return functions, nil	
}




func (this *Py_info) GetClasses() (classes []Class_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// get parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(py_info_get_classes_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_info_get_classes_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_info.get_classes. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	classesAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if classesAsInterface != nil{
		 
		// handle
		
		 
		if len(classesAsInterface.([]interface{})) > 0{
			classes = make([]Class_info, len(classesAsInterface.([]interface{})))
			if _, ok := classesAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range classesAsInterface.([]interface{}){
					classes[i] = Class_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range classesAsInterface.([]interface{}){
					classes[i] = obj.(Class_info)
				}
			}
		}
		
		

		
	}

	

	return classes, nil	
}





func (this *Py_info) ReleasepyInfo( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(py_info_Releasepy_info_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_info_Releasepy_info_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_info.Releasepy_info. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}


type Py_extractor struct{
	h Handle
}


func NewPyExtractor( filename string) (instance *Py_extractor, err error){
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// parameters
	
	fromGoToCDT(filename, parametersCDTS, 0)
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(py_extractor_py_extractor_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_extractor_py_extractor_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_extractor.py_extractor. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	inst := &Py_extractor{}

	
	new_instanceAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if new_instanceAsInterface != nil{
		inst.h = new_instanceAsInterface.(Handle)
	} else {
		return nil, fmt.Errorf("Object creation returned nil")
	}
		
	

	return inst, nil	
}


func (this *Py_extractor) GetHandle() Handle{
	return this.h
}

func (this *Py_extractor) SetHandle(h Handle){
	this.h = h
}



func (this *Py_extractor) Extract() (info Py_info, err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 1)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt
	return_valuesCDTS := xcall_params_slice[1].pcdt

	
	// parameters
	
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_ret(py_extractor_extract_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_extractor_extract_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_extractor.extract. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	
	infoAsInterface := fromCDTToGo(return_valuesCDTS, 0)
	if infoAsInterface != nil{
		 		
		
		
		
		if obj, ok := infoAsInterface.(Handle); ok{ // None Go object			
			info = Py_info{ h: obj }
		} else {
			info = Py_info(infoAsInterface.(Py_info))
		}
		

		
	}
	
	

	return info, nil
}


func (this *Py_extractor) ReleasepyExtractor( this_instance interface{}) ( err error){
	
	

	xcall_params := C.xllr_alloc_cdts_buffer(1, 0)
	xcall_params_slice := (*[1 << 30]C.cdts)(unsafe.Pointer(xcall_params))[:2:2]
	parametersCDTS := xcall_params_slice[0].pcdt

	
	// parameters
	fromGoToCDT(this.h, parametersCDTS, 0) // object
	

		var out_err *C.char
	var out_err_len C.uint64_t
	out_err_len = C.uint64_t(0)
	
	C.xllr_xcall_params_no_ret(py_extractor_Releasepy_extractor_id, xcall_params, &out_err, &out_err_len)  // call function pointer py_extractor_Releasepy_extractor_id via XLLR
	
	// check errors
	if out_err_len != 0{
		err = fmt.Errorf("Function failed py_extractor.Releasepy_extractor. Error: %v", string(C.GoBytes(unsafe.Pointer(out_err), C.int(out_err_len))))
		return
	}

	
	

	return  nil
}




