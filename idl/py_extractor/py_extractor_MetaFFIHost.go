
// Code generated by MetaFFI. DO NOT EDIT.
// Host code for py_extractor.json
package py_extractor

import "fmt"
import "unsafe"
import . "github.com/MetaFFI/lang-plugin-go/go-runtime"



// function IDs








var variable_info_get_name_id unsafe.Pointer


var variable_info_get_type_id unsafe.Pointer


var variable_info_get_is_getter_id unsafe.Pointer


var variable_info_get_is_setter_id unsafe.Pointer





var variable_info_Releasevariable_info_id unsafe.Pointer



var parameter_info_get_name_id unsafe.Pointer


var parameter_info_get_type_id unsafe.Pointer


var parameter_info_get_is_default_value_id unsafe.Pointer


var parameter_info_get_is_optional_id unsafe.Pointer


var parameter_info_get_kind_id unsafe.Pointer





var parameter_info_Releaseparameter_info_id unsafe.Pointer



var function_info_get_name_id unsafe.Pointer


var function_info_get_comment_id unsafe.Pointer


var function_info_get_parameters_id unsafe.Pointer


var function_info_get_return_values_id unsafe.Pointer





var function_info_Releasefunction_info_id unsafe.Pointer



var class_info_get_name_id unsafe.Pointer


var class_info_get_comment_id unsafe.Pointer


var class_info_get_fields_id unsafe.Pointer


var class_info_get_methods_id unsafe.Pointer





var class_info_Releaseclass_info_id unsafe.Pointer



var py_info_get_globals_id unsafe.Pointer


var py_info_get_functions_id unsafe.Pointer


var py_info_get_classes_id unsafe.Pointer





var py_info_Releasepy_info_id unsafe.Pointer




var py_extractor_extract_id unsafe.Pointer


var py_extractor_py_extractor_id unsafe.Pointer


var py_extractor_Releasepy_extractor_id unsafe.Pointer




func Load(modulePath string){
	LoadCDTCAPI()

	runtimePlugin := "xllr.python3"
	err := XLLRLoadRuntimePlugin(runtimePlugin)
	if err != nil{
		panic(err)
	}

	// load functions
	loadFF := func(modulePath string, fpath string, paramsCount int8, retvalCount int8) unsafe.Pointer{
		id, err := XLLRLoadFunction(runtimePlugin, modulePath, fpath, nil, paramsCount, retvalCount)
		if err != nil{ // failed
			panic(err)
		}

		return id
	}

	
	

	

	
	
	variable_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_type_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_type,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_is_getter_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_is_getter,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	variable_info_get_is_setter_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_get_is_setter,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	variable_info_Releasevariable_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_variable_info_Releasevariable_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	parameter_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_type_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_type,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_is_default_value_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_is_default_value,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_is_optional_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_is_optional,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	parameter_info_get_kind_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_get_kind,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	parameter_info_Releaseparameter_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_parameter_info_Releaseparameter_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	function_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_comment_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_comment,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_parameters_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_parameters,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	function_info_get_return_values_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_get_return_values,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	function_info_Releasefunction_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_function_info_Releasefunction_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	class_info_get_name_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_name,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_comment_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_comment,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_fields_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_fields,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	class_info_get_methods_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_get_methods,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	class_info_Releaseclass_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_class_info_Releaseclass_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	py_info_get_globals_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_globals,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_info_get_functions_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_functions,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_info_get_classes_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_get_classes,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	
	
	
	py_info_Releasepy_info_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_info_Releasepy_info,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
	
	py_extractor_extract_id = loadFF(modulePath, `entrypoint_class=py_extractor,entrypoint_function=EntryPoint_py_extractor_extract,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_extractor_py_extractor_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_extractor_py_extractor,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 1)
	
	
	py_extractor_Releasepy_extractor_id = loadFF(modulePath, `entrypoint_function=EntryPoint_py_extractor_Releasepy_extractor,metaffi_guest_lib=py_extractor_MetaFFIGuest,module=py_extractor`, 1, 0)
	
	
	
}

func Free(){
	err := XLLRFreeRuntimePlugin("xllr.python3")
	if err != nil{ panic(err) }
}









// Code to call foreign functions in module py_extractor via XLLR



type Variable_info struct{
	h Handle
}



func (this *Variable_info) GetHandle() Handle{
	return this.h
}

func (this *Variable_info) SetHandle(h Handle){
	this.h = h
}



func (this *Variable_info) GetName() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(variable_info_get_name_id, xcall_params)  // call function pointer variable_info_get_name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionvariable_info.get_name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Variable_info) GetType() (type__ string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(variable_info_get_type_id, xcall_params)  // call function pointer variable_info_get_type_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionvariable_info.get_type. Error: %v", err)
		return
	}

	
	
	type__AsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *Variable_info) GetIsGetter() (is_getter bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(variable_info_get_is_getter_id, xcall_params)  // call function pointer variable_info_get_is_getter_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionvariable_info.get_is_getter. Error: %v", err)
		return
	}

	
	
	is_getterAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if is_getterAsInterface != nil{
		
		// not handle
		is_getter = bool(is_getterAsInterface.(bool))
		
		
	}

	

	return is_getter, nil	
}




func (this *Variable_info) GetIsSetter() (is_setter bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(variable_info_get_is_setter_id, xcall_params)  // call function pointer variable_info_get_is_setter_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionvariable_info.get_is_setter. Error: %v", err)
		return
	}

	
	
	is_setterAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if is_setterAsInterface != nil{
		
		// not handle
		is_setter = bool(is_setterAsInterface.(bool))
		
		
	}

	

	return is_setter, nil	
}





func (this *Variable_info) ReleasevariableInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(variable_info_Releasevariable_info_id, xcall_params)  // call function pointer variable_info_Releasevariable_info_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionvariable_info.Releasevariable_info. Error: %v", err)
		return
	}

	
	

	return  nil
}


type Parameter_info struct{
	h Handle
}



func (this *Parameter_info) GetHandle() Handle{
	return this.h
}

func (this *Parameter_info) SetHandle(h Handle){
	this.h = h
}



func (this *Parameter_info) GetName() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(parameter_info_get_name_id, xcall_params)  // call function pointer parameter_info_get_name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.get_name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Parameter_info) GetType() (type__ string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(parameter_info_get_type_id, xcall_params)  // call function pointer parameter_info_get_type_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.get_type. Error: %v", err)
		return
	}

	
	
	type__AsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if type__AsInterface != nil{
		
		// not handle
		type__ = string(type__AsInterface.(string))
		
		
	}

	

	return type__, nil	
}




func (this *Parameter_info) GetIsDefaultValue() (is_default_value bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(parameter_info_get_is_default_value_id, xcall_params)  // call function pointer parameter_info_get_is_default_value_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.get_is_default_value. Error: %v", err)
		return
	}

	
	
	is_default_valueAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if is_default_valueAsInterface != nil{
		
		// not handle
		is_default_value = bool(is_default_valueAsInterface.(bool))
		
		
	}

	

	return is_default_value, nil	
}




func (this *Parameter_info) GetIsOptional() (is_optional bool, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(parameter_info_get_is_optional_id, xcall_params)  // call function pointer parameter_info_get_is_optional_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.get_is_optional. Error: %v", err)
		return
	}

	
	
	is_optionalAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if is_optionalAsInterface != nil{
		
		// not handle
		is_optional = bool(is_optionalAsInterface.(bool))
		
		
	}

	

	return is_optional, nil	
}




func (this *Parameter_info) GetKind() (kind string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(parameter_info_get_kind_id, xcall_params)  // call function pointer parameter_info_get_kind_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.get_kind. Error: %v", err)
		return
	}

	
	
	kindAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if kindAsInterface != nil{
		
		// not handle
		kind = string(kindAsInterface.(string))
		
		
	}

	

	return kind, nil	
}





func (this *Parameter_info) ReleaseparameterInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(parameter_info_Releaseparameter_info_id, xcall_params)  // call function pointer parameter_info_Releaseparameter_info_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionparameter_info.Releaseparameter_info. Error: %v", err)
		return
	}

	
	

	return  nil
}


type Function_info struct{
	h Handle
}



func (this *Function_info) GetHandle() Handle{
	return this.h
}

func (this *Function_info) SetHandle(h Handle){
	this.h = h
}



func (this *Function_info) GetName() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(function_info_get_name_id, xcall_params)  // call function pointer function_info_get_name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionfunction_info.get_name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Function_info) GetComment() (comment string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(function_info_get_comment_id, xcall_params)  // call function pointer function_info_get_comment_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionfunction_info.get_comment. Error: %v", err)
		return
	}

	
	
	commentAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if commentAsInterface != nil{
		
		// not handle
		comment = string(commentAsInterface.(string))
		
		
	}

	

	return comment, nil	
}




func (this *Function_info) GetParameters() (parameters []Parameter_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(function_info_get_parameters_id, xcall_params)  // call function pointer function_info_get_parameters_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionfunction_info.get_parameters. Error: %v", err)
		return
	}

	
	
	parametersAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if parametersAsInterface != nil{
		 
		// handle
		
		 
		if len(parametersAsInterface.([]interface{})) > 0{
			parameters = make([]Parameter_info, len(parametersAsInterface.([]interface{})))
			if _, ok := parametersAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range parametersAsInterface.([]interface{}){
					parameters[i] = Parameter_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range parametersAsInterface.([]interface{}){
					parameters[i] = obj.(Parameter_info)
				}
			}
		}
		
		

		
	}

	

	return parameters, nil	
}




func (this *Function_info) GetReturnValues() (return_values []string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(function_info_get_return_values_id, xcall_params)  // call function pointer function_info_get_return_values_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionfunction_info.get_return_values. Error: %v", err)
		return
	}

	
	
	return_valuesAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if return_valuesAsInterface != nil{
		
		// not handle
		return_values = []string(return_valuesAsInterface.([]string))
		
		
	}

	

	return return_values, nil	
}





func (this *Function_info) ReleasefunctionInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(function_info_Releasefunction_info_id, xcall_params)  // call function pointer function_info_Releasefunction_info_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionfunction_info.Releasefunction_info. Error: %v", err)
		return
	}

	
	

	return  nil
}


type Class_info struct{
	h Handle
}



func (this *Class_info) GetHandle() Handle{
	return this.h
}

func (this *Class_info) SetHandle(h Handle){
	this.h = h
}



func (this *Class_info) GetName() (name string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(class_info_get_name_id, xcall_params)  // call function pointer class_info_get_name_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionclass_info.get_name. Error: %v", err)
		return
	}

	
	
	nameAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if nameAsInterface != nil{
		
		// not handle
		name = string(nameAsInterface.(string))
		
		
	}

	

	return name, nil	
}




func (this *Class_info) GetComment() (comment string, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(class_info_get_comment_id, xcall_params)  // call function pointer class_info_get_comment_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionclass_info.get_comment. Error: %v", err)
		return
	}

	
	
	commentAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if commentAsInterface != nil{
		
		// not handle
		comment = string(commentAsInterface.(string))
		
		
	}

	

	return comment, nil	
}




func (this *Class_info) GetFields() (fields []Variable_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(class_info_get_fields_id, xcall_params)  // call function pointer class_info_get_fields_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionclass_info.get_fields. Error: %v", err)
		return
	}

	
	
	fieldsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if fieldsAsInterface != nil{
		 
		// handle
		
		 
		if len(fieldsAsInterface.([]interface{})) > 0{
			fields = make([]Variable_info, len(fieldsAsInterface.([]interface{})))
			if _, ok := fieldsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range fieldsAsInterface.([]interface{}){
					fields[i] = Variable_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range fieldsAsInterface.([]interface{}){
					fields[i] = obj.(Variable_info)
				}
			}
		}
		
		

		
	}

	

	return fields, nil	
}




func (this *Class_info) GetMethods() (methods []Function_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(class_info_get_methods_id, xcall_params)  // call function pointer class_info_get_methods_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionclass_info.get_methods. Error: %v", err)
		return
	}

	
	
	methodsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if methodsAsInterface != nil{
		 
		// handle
		
		 
		if len(methodsAsInterface.([]interface{})) > 0{
			methods = make([]Function_info, len(methodsAsInterface.([]interface{})))
			if _, ok := methodsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range methodsAsInterface.([]interface{}){
					methods[i] = Function_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range methodsAsInterface.([]interface{}){
					methods[i] = obj.(Function_info)
				}
			}
		}
		
		

		
	}

	

	return methods, nil	
}





func (this *Class_info) ReleaseclassInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(class_info_Releaseclass_info_id, xcall_params)  // call function pointer class_info_Releaseclass_info_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionclass_info.Releaseclass_info. Error: %v", err)
		return
	}

	
	

	return  nil
}


type Py_info struct{
	h Handle
}



func (this *Py_info) GetHandle() Handle{
	return this.h
}

func (this *Py_info) SetHandle(h Handle){
	this.h = h
}



func (this *Py_info) GetGlobals() (globals []Variable_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(py_info_get_globals_id, xcall_params)  // call function pointer py_info_get_globals_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_info.get_globals. Error: %v", err)
		return
	}

	
	
	globalsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if globalsAsInterface != nil{
		 
		// handle
		
		 
		if len(globalsAsInterface.([]interface{})) > 0{
			globals = make([]Variable_info, len(globalsAsInterface.([]interface{})))
			if _, ok := globalsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range globalsAsInterface.([]interface{}){
					globals[i] = Variable_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range globalsAsInterface.([]interface{}){
					globals[i] = obj.(Variable_info)
				}
			}
		}
		
		

		
	}

	

	return globals, nil	
}




func (this *Py_info) GetFunctions() (functions []Function_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(py_info_get_functions_id, xcall_params)  // call function pointer py_info_get_functions_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_info.get_functions. Error: %v", err)
		return
	}

	
	
	functionsAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if functionsAsInterface != nil{
		 
		// handle
		
		 
		if len(functionsAsInterface.([]interface{})) > 0{
			functions = make([]Function_info, len(functionsAsInterface.([]interface{})))
			if _, ok := functionsAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range functionsAsInterface.([]interface{}){
					functions[i] = Function_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range functionsAsInterface.([]interface{}){
					functions[i] = obj.(Function_info)
				}
			}
		}
		
		

		
	}

	

	return functions, nil	
}




func (this *Py_info) GetClasses() (classes []Class_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// get parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0)
	
	 


		err = XLLRXCallParamsRet(py_info_get_classes_id, xcall_params)  // call function pointer py_info_get_classes_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_info.get_classes. Error: %v", err)
		return
	}

	
	
	classesAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if classesAsInterface != nil{
		 
		// handle
		
		 
		if len(classesAsInterface.([]interface{})) > 0{
			classes = make([]Class_info, len(classesAsInterface.([]interface{})))
			if _, ok := classesAsInterface.([]interface{})[0].(Handle); ok{
				for i, h := range classesAsInterface.([]interface{}){
					classes[i] = Class_info{ h: h.(Handle) }
				}
			} else {
				for i, obj := range classesAsInterface.([]interface{}){
					classes[i] = obj.(Class_info)
				}
			}
		}
		
		

		
	}

	

	return classes, nil	
}





func (this *Py_info) ReleasepyInfo( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(py_info_Releasepy_info_id, xcall_params)  // call function pointer py_info_Releasepy_info_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_info.Releasepy_info. Error: %v", err)
		return
	}

	
	

	return  nil
}


type Py_extractor struct{
	h Handle
}


func NewPyExtractor( filename string) (instance *Py_extractor, err error){
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// parameters
	
	FromGoToCDT(filename, parametersCDTS, 0)
	

		err = XLLRXCallParamsRet(py_extractor_py_extractor_id, xcall_params)  // call function pointer py_extractor_py_extractor_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_extractor.py_extractor. Error: %v", err)
		return
	}

	
	inst := &Py_extractor{}

	
	new_instanceAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if new_instanceAsInterface != nil{
		inst.h = new_instanceAsInterface.(Handle)
	} else {
		return nil, fmt.Errorf("Object creation returned nil")
	}
		
	

	return inst, nil	
}


func (this *Py_extractor) GetHandle() Handle{
	return this.h
}

func (this *Py_extractor) SetHandle(h Handle){
	this.h = h
}



func (this *Py_extractor) Extract() (info Py_info, err error){
	
	

	xcall_params, parametersCDTS, return_valuesCDTS := XLLRAllocCDTSBuffer(1, 1)

	
	// parameters
	
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	
	

		err = XLLRXCallParamsRet(py_extractor_extract_id, xcall_params)  // call function pointer py_extractor_extract_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_extractor.extract. Error: %v", err)
		return
	}

	
	
	infoAsInterface := FromCDTToGo(return_valuesCDTS, 0)
	if infoAsInterface != nil{
		 		
		
		
		
		if obj, ok := infoAsInterface.(Handle); ok{ // None Go object			
			info = Py_info{ h: obj }
		} else {
			info = Py_info(infoAsInterface.(Py_info))
		}
		

		
	}
	
	

	return info, nil
}


func (this *Py_extractor) ReleasepyExtractor( this_instance interface{}) ( err error){
	
	xcall_params, parametersCDTS, _ := XLLRAllocCDTSBuffer(1, 0)

	
	// parameters
	FromGoToCDT(this.h, parametersCDTS, 0) // object
	

		err = XLLRXCallParamsNoRet(py_extractor_Releasepy_extractor_id, xcall_params)  // call function pointer py_extractor_Releasepy_extractor_id via XLLR
	
	// check errors
	if err != nil{
		err = fmt.Errorf("Failed calling functionpy_extractor.Releasepy_extractor. Error: %v", err)
		return
	}

	
	

	return  nil
}




