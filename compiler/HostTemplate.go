package main

const HostHeaderTemplate = `
# Code generated by OpenFFI. DO NOT EDIT.
# Guest code for {{.IDLFilenameWithExtension}}
`

const HostImports = `
from ctypes import *
import ctypes.util
from typing import List
import platform
import os
from enum import Enum
`

const HostHelperFunctions = `
xllr_handle = None
python_plugin_handle = None

def free_openffi():
	global xllr_handle
	global runtime_plugin

	err = pointer((c_char * 1)(0))
	err_len = (c_ulonglong)(0)
	xllr_handle.free_runtime_plugin(runtime_plugin, len(runtime_plugin), byref(err), byref(err_len))

def load_xllr_and_python_plugin():
	global xllr_handle
	global python_plugin_handle
	
	if xllr_handle == None:
		xllr_handle = cdll.LoadLibrary(get_filename_to_load('xllr'))

	if python_plugin_handle == None:
		python_plugin_handle = cdll.LoadLibrary(get_filename_to_load('xllr.python3'))

	# set restypes
	python_plugin_handle.convert_host_params_to_cdts.argstype = [py_object, py_object]
	python_plugin_handle.convert_host_return_values_from_cdts.argstype = [py_object, py_object]
	python_plugin_handle.convert_host_return_values_from_cdts.restype = py_object

def get_filename_to_load(fname):
	osname = platform.system()
	if osname == 'Windows':
		return os.getenv('OPENFFI_HOME')+'\\'+ fname + '.dll'
	elif osname == 'Darwin':
		return os.getenv('OPENFFI_HOME')+'/' + fname + '.dylib'
	else:
		return os.getenv('OPENFFI_HOME')+'/' + fname + '.so' # for everything that is not windows or mac, return .so
`

const (
	HostFunctionStubsTemplate = `
{{$pfn := .IDLFilename}}
{{range $mindex, $m := .Modules}}
{{$targetLang := $m.TargetLanguage}}
# Code to call foreign functions in module {{$m.Name}} via XLLR
{{range $findex, $f := $m.Functions}}
# Call to foreign {{$f.PathToForeignFunction.function}}
{{$f.PathToForeignFunction.function}}_id = -1
runtime_plugin = """xllr.{{$targetLang}}""".encode("utf-8")
def {{$f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{$elem.Name}}:{{ConvertToPythonTypeFromField $elem}}{{end}}) -> ({{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{ConvertToPythonTypeFromField $elem}}{{end}}):

	global xllr_handle
	global {{$f.PathToForeignFunction.function}}_id
	global runtime_plugin
	global python_plugin_handle

	bufIndex = 0

	load_xllr_and_python_plugin()

	# load function
	if {{$f.PathToForeignFunction.function}}_id == -1:
		function_path = """{{$f.PathToForeignFunctionAsString}}""".encode("utf-8")
		err = POINTER(c_ubyte)()
		out_err = POINTER(POINTER(c_ubyte))(c_void_p(addressof(err)))
		err_len = c_uint32()
		out_err_len = POINTER(c_uint32)(c_void_p(addressof(err_len)))

		{{$f.PathToForeignFunction.function}}_id = xllr_handle.load_function(runtime_plugin, len(runtime_plugin), function_path, len(function_path), {{$f.PathToForeignFunction.function}}_id, out_err, out_err_len)
		if {{$f.PathToForeignFunction.function}}_id == -1: # failed to load function
			err_text = string_at(out_err.contents, out_err_len.contents.value)
			raise RuntimeError('\n'+str(err_text).replace("\\n", "\n"))

	params = ({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{$elem.Name}}{{end}})
	params_types = ({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{GetOpenFFIType $elem}}{{end}})
	parameters_buffer = python_plugin_handle.convert_host_params_to_cdts(py_object(params), py_object(params_types))
	return_values_buffer = xllr_handle.alloc_cdts_buffer({{len $f.ReturnValues}})

	# call function
	
	out_error = ({{ConvertToCPythonType "string8"}} * 1)(0)
	out_error_len = ({{ConvertToCPythonType "size"}})(0)
	xllr_handle.call(runtime_plugin, len(runtime_plugin), \
					{{$f.PathToForeignFunction.function}}_id, \
					parameters_buffer, {{len $f.Parameters}}, \
					return_values_buffer, {{len $f.ReturnValues}}, \
					out_error, byref(out_error_len))
	
	
	# check for error
	if out_error != None and out_error[0] != None:
		err_msg = string_at(out_error[0], out_error_len.value).decode('utf-8')
		raise RuntimeError('\n'+err_msg.replace("\\n", "\n"))

	# unpack results
	# the function sets local variables with the return values names
	return_values_name = ({{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}} 'ret_{{$elem.Name}}'{{end}})

	#import time
	#time.sleep(20)

	ret_vals = python_plugin_handle.convert_host_return_values_from_cdts(py_object(return_values_name), c_void_p(return_values_buffer))

	return {{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}ret_vals[{{$index}}]{{end}}

{{end}}{{end}}
`
)
