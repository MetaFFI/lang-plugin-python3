package main

const HostHeaderTemplate = `
# Code generated by OpenFFI. DO NOT EDIT.
# Guest code for {{.IDLFilenameWithExtension}}
`

const HostImports = `
from ctypes import *
import ctypes.util
from typing import List
import platform
import os
`

const HostHelperFunctions = `
xllrHandle = None

def free_openffi():
	global xllrHandle
	global runtime_plugin

	err = pointer((c_char * 1)(0))
	err_len = (c_ulonglong)(0)
	xllrHandle.free_runtime_plugin(runtime_plugin, len(runtime_plugin), byref(err), byref(err_len))

def load_xllr():
	global xllrHandle
	
	if xllrHandle == None:
		xllrHandle = cdll.LoadLibrary(get_filename_to_load('xllr'))

	# set restypes
	xllrHandle.get_openffi_string_element.restype = c_char_p

def get_filename_to_load(fname):
	osname = platform.system()
	if osname == 'Windows':
		return os.getenv('OPENFFI_HOME')+'\\'+ fname + '.dll'
	elif osname == 'Darwin':
		return os.getenv('OPENFFI_HOME')+'/' + fname + '.dylib'
	else:
		return os.getenv('OPENFFI_HOME')+'/' + fname + '.so' # for everything that is not windows or mac, return .so



`

const HostFunctionStubsTemplate = `
{{$pfn := .IDLFilename}}
{{range $mindex, $m := .Modules}}
{{$targetLang := $m.TargetLanguage}}
# Code to call foreign functions in module {{$m.Name}} via XLLR
{{range $findex, $f := $m.Functions}}
# Call to foreign {{$f.PathToForeignFunction.function}}
{{$f.PathToForeignFunction.function}}_id = -1
runtime_plugin = """xllr.{{$targetLang}}""".encode("utf-8")
def {{$f.PathToForeignFunction.function}}({{range $index, $elem := $f.Parameters}}{{if $index}},{{end}} {{$elem.Name}}:{{ConvertToPythonTypeFromField $elem}}{{end}}) -> ({{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{ConvertToPythonTypeFromField $elem}}{{end}}):

	global xllrHandle
	global {{$f.PathToForeignFunction.function}}_id
	global runtime_plugin

	bufIndex = 0

	# load XLLR
	load_xllr()

	# load function
	if {{$f.PathToForeignFunction.function}}_id == -1:
		function_path = """{{$f.PathToForeignFunctionAsString}}""".encode("utf-8")
		err = POINTER(c_ubyte)()
		out_err = POINTER(POINTER(c_ubyte))(c_void_p(addressof(err)))
		err_len = c_uint32()
		out_err_len = POINTER(c_uint32)(c_void_p(addressof(err_len)))

		{{$f.PathToForeignFunction.function}}_id = xllrHandle.load_function(runtime_plugin, len(runtime_plugin), function_path, len(function_path), {{$f.PathToForeignFunction.function}}_id, out_err, out_err_len)
		if {{$f.PathToForeignFunction.function}}_id == -1: # failed to load function
			err_text = string_at(out_err.contents, out_err_len.contents.value)
			raise RuntimeError('\n'+str(err_text).replace("\\n", "\n"))

	
	# pack parameters
	{{$parametersLength := len $f.Parameters}}{{if gt $parametersLength 0}}parametersBuffer = xllrHandle.alloc_args_buffer({{CalculateArgsLength $f.Parameters}}){{end}}
	{{$returnValuesLength := len $f.ReturnValues}}{{if gt $returnValuesLength 0}}returnValuesBuffer = xllrHandle.alloc_args_buffer({{CalculateArgsLength $f.ReturnValues}}){{end}}
	
	{{range $index, $elem := $f.Parameters}}	
	{{if $elem.IsString}}
	{{if $elem.IsArray}}
	# string array
	in_{{$elem.Name}}_len = {{ConvertToCPythonType "openffi_size"}}(len({{$elem.Name}}))
	in_{{$elem.Name}} = ({{ConvertToCPythonType "openffi_string"}} * len({{$elem.Name}}))(0)
	in_{{$elem.Name}}_sizes = ({{ConvertToCPythonType "openffi_size"}} * len({{$elem.Name}}))(0)

	i = 0
	{{$elem.Name}}_py_array = [] # to keep a reference to the parameters
	for val in {{$elem.Name}}:
		encval = val.encode('utf-8')
		{{$elem.Name}}_py_array.append(encval)
		xllrHandle.set_openffi_string_element(i, in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, encval, len(encval))
		i = i+1

	xllrHandle.set_arg_openffi_string_array(parametersBuffer, bufIndex, in_{{$elem.Name}}, in_{{$elem.Name}}_sizes, byref(in_{{$elem.Name}}_len))
	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{else}}
	# string
	{{$elem.Name}}_encval = {{$elem.Name}}.encode('utf-8')
	{{$elem.Name}}_encval_len = {{ConvertToCPythonType "openffi_size"}}(len({{$elem.Name}}_encval))
	xllrHandle.set_arg_openffi_string(parametersBuffer, bufIndex, {{$elem.Name}}_encval, byref({{$elem.Name}}_encval_len))
	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{end}}
	{{else}}
	{{if $elem.IsArray}}
	# non-string array
	in_{{$elem.Name}}_len = {{ConvertToCPythonType "openffi_size"}}(len({{$elem.Name}}))
	in_{{$elem.Name}} = ({{ConvertToCPythonType $elem.Type}} * len({{$elem.Name}}))(0)

	i = 0
	for val in {{$elem.Name}}:
		xllrHandle.set_openffi_{{$elem.Type}}_element(in_{{$elem.Name}}, i, val)
		i = i+1

	xllrHandle.set_arg_openffi_{{$elem.Type}}_array(parametersBuffer, bufIndex, in_{{$elem.Name}}, byref(in_{{$elem.Name}}_len))
	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{else}}
	# non-string
	c{{$elem.Name}} = {{ConvertToCPythonType $elem.Type}}({{$elem.Name}})
	xllrHandle.set_arg_openffi_{{$elem.Type}}(parametersBuffer, bufIndex, byref(c{{$elem.Name}}))
	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{end}}
	{{end}}
	{{end}}

	# call function
	
	out_error = ({{ConvertToCPythonType "openffi_string"}} * 1)(0)
	out_error_len = ({{ConvertToCPythonType "openffi_size"}})(0)
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
					{{$f.PathToForeignFunction.function}}_id, \
					parametersBuffer, {{$parametersLength}}, \
					returnValuesBuffer, {{$returnValuesLength}}, \
					out_error, byref(out_error_len))
	
	
	# check for error
	if out_error != None and out_error[0] != None:
		err_msg = string_at(out_error[0], out_error_len.value).decode('utf-8')
		raise RuntimeError('\n'+err_msg.replace("\\n", "\n"))

	# unpack results
	bufIndex = 0
	{{range $index, $elem := $f.ReturnValues}}	
	{{if $elem.IsString}}
	{{if $elem.IsArray}}
	# string array (TODO: support utf-16/utf-32)
	{{$elem.Name}} = []
	out_{{$elem.Name}}_sizes = pointer(({{ConvertToCPythonType "openffi_size"}} * 1)(0))
	out_{{$elem.Name}}_length = ({{ConvertToCPythonType "openffi_size"}})(0)
	out_{{$elem.Name}} = xllrHandle.get_arg_openffi_string_array(returnValuesBuffer, bufIndex, byref(out_{{$elem.Name}}_sizes), byref(out_{{$elem.Name}}_length))

	i = 0
	
	for i in range(out_{{$elem.Name}}_length.value):
		val_len = ({{ConvertToCPythonType "openffi_size"}})(0)
		val = (xllrHandle.get_openffi_string_element(i, out_{{$elem.Name}}, out_{{$elem.Name}}_sizes, byref(val_len)))
		{{$elem.Name}}.append(string_at(val, val_len.value).decode('utf-8'))
		i = i+1

	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{else}}
	# string
	out_{{$elem.Name}} = ({{ConvertToCPythonType "openffi_string"}} * 1)(0)
	out_{{$elem.Name}}_length = ({{ConvertToCPythonType "openffi_string"}})(0)
	xllrHandle.get_arg_openffi_string(returnValuesBuffer, bufIndex, byref(out_{{$elem.Name}}), byref(out_{{$elem.Name}}_length))
	
	{{$elem.Name}} = string_at(out_{{$elem.Name}}, out_{{$elem.Name}}_length.value).decode('utf-8')

	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{end}}
	{{else}}
	{{if $elem.IsArray}}
	# non-string array
	
	{{$elem.Name}} = []
	out_{{$elem.Name}} = ({{ConvertToCPythonType $elem.Type}} * 1)(0)
	out_{{$elem.Name}}_length = ({{ConvertToCPythonType "openffi_size"}})(0)
	xllrHandle.get_arg_openffi_{{$elem.Type}}_array(returnValuesBuffer, bufIndex, byref(out_{{$elem.Name}}), byref(out_{{$elem.Name}}_length))

	i = 0
	
	for i in out_{{$elem.Name}}_length:
		val = (xllrHandle.get_{{$elem.Type}}_element(i, out_{{$elem.Name}}))
		{{$elem.Name}}.append({{ConvertToPythonType "openffi_size" false}}(val))
		i = i+1

	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{else}}
	# non-string
	{{$elem.Name}} = {{ConvertToPythonType "openffi_size" false}}(xllrHandle.get_arg_openffi_{{$elem.Type}}(returnValuesBuffer, bufIndex))
	bufIndex = bufIndex + {{CalculateArgLength $elem}}
	{{end}}
	{{end}}
	{{end}}

	return {{range $index, $elem := $f.ReturnValues}}{{if $index}},{{end}}{{$elem.Name}}{{end}}

{{end}}{{end}}
`
