package main

const HostTemplate = `
# Code generated by OpenFFI. DO NOT EDIT.
# Host code for {{.ProtoIDLFilename}}
{{ $pfn := .ProtoIDLFilenameNoExtension}}
{{ $targetLang := .TargetLanguage}}
from {{.ProtobufFilename}} import *
from ctypes import *
import ctypes.util
from typing import List
import platform
import os

xllrHandle = None
def free_openffi():
		return # TODO: implement free library. not supported by cdll.

def load_xllr():
	global xllrHandle
	if xllrHandle == None:
		xllrHandle = cdll.LoadLibrary(get_filename_to_load('xllr'))

def get_filename_to_load(fname):
	osname = platform.system()
	if osname == 'Windows':
		return ctypes.util.find_library(fname + '.dll')
	elif osname == 'Darwin':
		return fname + '.dylib'
	else:
		return fname + '.so' # for everything that is not windows or mac, return .so

{{range $mindex, $m := .Modules}}

# Code to call foreign functions in module {{$m.Name}} via XLLR

{{range $findex, $f := $m.Functions}}

# Call to foreign {{.ForeignFunctionName}}
def {{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} {{$elem.Name}}:{{$elem.Type}}{{end}}) -> ({{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.Type}}{{end}}):
	
	# serialize parameters
	req = {{$f.ProtobufRequestStruct}}()
	{{range $index, $elem := $f.ExpandedParameters}}

	if getattr(req.{{$elem.Name}}, 'extend', None) != None: # if repeated value, use append
		req.{{$elem.Name}}.extend({{$elem.Name}})
	elif getattr(req.{{$elem.Name}}, 'CopyFrom', None) != None: # if proto message
		req.{{$elem.Name}}.CopyFrom({{$elem.Name}})
	else:
		req.{{$elem.Name}} = {{$elem.Name}}

	{{end}}

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.{{$targetLang}}""".encode("utf-8")
	module_name = """{{$pfn}}OpenFFIGuest""".encode("utf-8")
	func_name = """Foreign{{$f.ForeignFunctionName}}""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = {{$f.ProtobufResponseStruct}}()
	ret.ParseFromString(protoData)

	return {{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}ret.{{$elem.Name}}{{end}}
	

{{end}}

{{end}}
`
